<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Testes - Contador GitHub Nativo</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .test-suite { margin-bottom: 30px; border: 1px solid #ddd; padding: 15px; }
    .test-case { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; }
    .test-pass { border-left-color: #4CAF50; background: #f1f8e9; }
    .test-fail { border-left-color: #f44336; background: #ffebee; }
    .test-pending { border-left-color: #ff9800; background: #fff3e0; }
    .results { margin-top: 20px; padding: 15px; background: #f5f5f5; }
    button { padding: 10px 20px; margin: 5px; cursor: pointer; }
  </style>
</head>
<body>
  <h1>ðŸ§ª Testes do Contador GitHub Nativo</h1>
  
  <div>
    <button onclick="runAllTests()">Executar Todos os Testes</button>
    <button onclick="clearResults()">Limpar Resultados</button>
  </div>
  
  <div id="test-results"></div>
  
  <!-- Carregar dependÃªncias -->
  <script src="../js/contador-github-nativo.js"></script>
  
  <script>
    // Framework de testes simples
    class TestFramework {
      constructor() {
        this.results = [];
        this.currentSuite = null;
      }
      
      describe(name, callback) {
        this.currentSuite = { name, tests: [] };
        callback();
        this.results.push(this.currentSuite);
        this.currentSuite = null;
      }
      
      it(description, callback) {
        const test = { description, status: 'pending', error: null };
        
        try {
          const result = callback();
          if (result instanceof Promise) {
            return result.then(() => {
              test.status = 'pass';
            }).catch(error => {
              test.status = 'fail';
              test.error = error.message;
            });
          } else {
            test.status = 'pass';
          }
        } catch (error) {
          test.status = 'fail';
          test.error = error.message;
        }
        
        this.currentSuite.tests.push(test);
        return Promise.resolve();
      }
      
      expect(actual) {
        return {
          toBe: (expected) => {
            if (actual !== expected) {
              throw new Error(`Expected ${expected}, got ${actual}`);
            }
          },
          toEqual: (expected) => {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
              throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
            }
          },
          toBeTruthy: () => {
            if (!actual) {
              throw new Error(`Expected truthy value, got ${actual}`);
            }
          },
          toBeFalsy: () => {
            if (actual) {
              throw new Error(`Expected falsy value, got ${actual}`);
            }
          },
          toThrow: () => {
            if (typeof actual !== 'function') {
              throw new Error('Expected a function');
            }
            try {
              actual();
              throw new Error('Expected function to throw');
            } catch (e) {
              // Expected
            }
          }
        };
      }
      
      renderResults() {
        const container = document.getElementById('test-results');
        let html = '';
        let totalTests = 0;
        let passedTests = 0;
        
        this.results.forEach(suite => {
          html += `<div class="test-suite">`;
          html += `<h2>${suite.name}</h2>`;
          
          suite.tests.forEach(test => {
            totalTests++;
            const cssClass = `test-${test.status}`;
            if (test.status === 'pass') passedTests++;
            
            html += `<div class="test-case ${cssClass}">`;
            html += `<strong>${test.status.toUpperCase()}:</strong> ${test.description}`;
            if (test.error) {
              html += `<br><small>Error: ${test.error}</small>`;
            }
            html += `</div>`;
          });
          
          html += `</div>`;
        });
        
        html += `<div class="results">`;
        html += `<h3>Resultados: ${passedTests}/${totalTests} testes passaram</h3>`;
        html += `<p>Taxa de sucesso: ${Math.round((passedTests/totalTests) * 100)}%</p>`;
        html += `</div>`;
        
        container.innerHTML = html;
      }
    }
    
    const test = new TestFramework();
    
    // Mock do fetch para testes
    const originalFetch = window.fetch;
    function mockFetch(url, options) {
      // Simular diferentes respostas baseadas na URL
      if (url.includes('contents/data/contador.json')) {
        if (options && options.method === 'PUT') {
          // Simular sucesso no commit
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve({
              content: { sha: 'new-sha-123' }
            }),
            headers: new Map([
              ['X-RateLimit-Remaining', '4999'],
              ['X-RateLimit-Reset', Math.floor(Date.now() / 1000) + 3600]
            ])
          });
        } else {
          // Simular obtenÃ§Ã£o do arquivo
          const mockData = {
            totalEtiquetas: 19452,
            ultimaAtualizacao: new Date().toISOString(),
            breakdown: { placas: 0, caixa: 0, avulso: 0, enderec: 0, transfer: 0, termo: 0 }
          };
          
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve({
              content: btoa(JSON.stringify(mockData)),
              sha: 'mock-sha-123'
            }),
            headers: new Map([
              ['X-RateLimit-Remaining', '5000'],
              ['X-RateLimit-Reset', Math.floor(Date.now() / 1000) + 3600]
            ])
          });
        }
      }
      
      // Fallback para outras URLs
      return originalFetch(url, options);
    }
    
    // Testes
    async function runAllTests() {
      // Substituir fetch por mock
      window.fetch = mockFetch;
      
      test.describe('ContadorGitHubNativo - Construtor', () => {
        test.it('deve criar instÃ¢ncia com configuraÃ§Ã£o padrÃ£o', () => {
          const contador = new ContadorGitHubNativo();
          test.expect(contador.owner).toBe('SEU_USUARIO_GITHUB');
          test.expect(contador.repo).toBe('SEU_REPOSITORIO');
          test.expect(contador.branch).toBe('main');
        });
        
        test.it('deve aceitar configuraÃ§Ã£o customizada', () => {
          const config = {
            owner: 'test-user',
            repo: 'test-repo',
            branch: 'develop',
            token: 'test-token'
          };
          const contador = new ContadorGitHubNativo(config);
          test.expect(contador.owner).toBe('test-user');
          test.expect(contador.repo).toBe('test-repo');
          test.expect(contador.branch).toBe('develop');
          test.expect(contador.token).toBe('test-token');
        });
      });
      
      test.describe('ContadorGitHubNativo - ValidaÃ§Ã£o', () => {
        test.it('deve validar incremento corretamente', () => {
          const contador = new ContadorGitHubNativo();
          test.expect(contador.validarIncremento(5, 'placas')).toBeTruthy();
          test.expect(contador.validarIncremento(0, 'placas')).toBeFalsy();
          test.expect(contador.validarIncremento(1001, 'placas')).toBeFalsy();
          test.expect(contador.validarIncremento(5, 'tipo-invalido')).toBeFalsy();
        });
        
        test.it('deve validar SHA corretamente', () => {
          const contador = new ContadorGitHubNativo();
          test.expect(contador.validarSHA('a1b2c3d4e5f6789012345678901234567890abcd')).toBeTruthy();
          test.expect(contador.validarSHA('invalid-sha')).toBeFalsy();
          test.expect(contador.validarSHA('')).toBeFalsy();
        });
      });
      
      test.describe('ContadorGitHubNativo - Cache', () => {
        test.it('deve gerenciar cache corretamente', () => {
          const contador = new ContadorGitHubNativo();
          
          // Cache inicialmente invÃ¡lido
          test.expect(contador.isCacheValid()).toBeFalsy();
          
          // Atualizar cache
          const mockData = { totalEtiquetas: 100 };
          contador.updateCache(mockData, 'test-sha');
          
          // Cache deve ser vÃ¡lido
          test.expect(contador.isCacheValid()).toBeTruthy();
          test.expect(contador.cache.contador).toEqual(mockData);
          test.expect(contador.cache.sha).toBe('test-sha');
        });
        
        test.it('deve limpar cache corretamente', () => {
          const contador = new ContadorGitHubNativo();
          contador.updateCache({ test: true }, 'sha');
          
          contador.clearCache();
          
          test.expect(contador.cache.contador).toBe(null);
          test.expect(contador.cache.sha).toBe(null);
          test.expect(contador.cache.timestamp).toBe(0);
        });
      });
      
      test.describe('ContadorGitHubNativo - Rate Limiting', () => {
        test.it('deve atualizar informaÃ§Ãµes de rate limit', () => {
          const contador = new ContadorGitHubNativo();
          
          const mockResponse = {
            headers: new Map([
              ['X-RateLimit-Remaining', '4500'],
              ['X-RateLimit-Reset', '1640995200'],
              ['X-RateLimit-Limit', '5000']
            ])
          };
          
          contador.updateRateLimitInfo(mockResponse);
          
          test.expect(contador.rateLimitInfo.remaining).toBe(4500);
          test.expect(contador.rateLimitInfo.limit).toBe(5000);
          test.expect(contador.rateLimitInfo.reset).toBe(1640995200000);
        });
      });
      
      test.describe('ContadorGitHubNativo - OperaÃ§Ãµes AssÃ­ncronas', () => {
        test.it('deve obter contador do GitHub', async () => {
          const contador = new ContadorGitHubNativo({
            owner: 'test-user',
            repo: 'test-repo',
            token: 'test-token'
          });
          
          const resultado = await contador.obterContador();
          
          test.expect(resultado.totalEtiquetas).toBe(19452);
          test.expect(resultado.breakdown).toBeTruthy();
        });
        
        test.it('deve incrementar contador', async () => {
          const contador = new ContadorGitHubNativo({
            owner: 'test-user',
            repo: 'test-repo',
            token: 'test-token'
          });
          
          // Primeiro obter o contador atual
          await contador.obterContador();
          
          // Depois incrementar
          const resultado = await contador.incrementarContador(5, 'placas');
          
          test.expect(resultado.totalEtiquetas).toBe(19457);
        });
      });
      
      test.describe('ContadorGitHubNativo - Merge de Conflitos', () => {
        test.it('deve fazer merge de contadores corretamente', async () => {
          const contador = new ContadorGitHubNativo();
          
          const versaoAtual = {
            totalEtiquetas: 100,
            breakdown: { placas: 50, caixa: 50 }
          };
          
          const novaVersao = {
            totalEtiquetas: 105,
            breakdown: { placas: 55, caixa: 50 }
          };
          
          // Simular cache
          contador.cache.contador = { totalEtiquetas: 100 };
          
          const merged = await contador.mergeContadores(versaoAtual, novaVersao);
          
          test.expect(merged.totalEtiquetas).toBe(105);
          test.expect(merged.breakdown.placas).toBe(55);
        });
      });
      
      // Restaurar fetch original
      window.fetch = originalFetch;
      
      // Renderizar resultados
      setTimeout(() => {
        test.renderResults();
      }, 100);
    }
    
    function clearResults() {
      document.getElementById('test-results').innerHTML = '';
      test.results = [];
    }
    
    console.log('ðŸ§ª Framework de testes carregado. Clique em "Executar Todos os Testes" para comeÃ§ar.');
  </script>
</body>
</html>